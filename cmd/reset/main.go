package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const resetTemplate = `// Code generated by reset-gen. DO NOT EDIT.
package {{.Package}}

{{range .Structs}}
func (r *{{.Name}}) Reset() {
	if r == nil {
		return
	}
{{range .Fields}}
	{{renderReset "r." .Name .Type}}
{{- end}}
}
{{end}}
`

type FieldInfo struct {
	Name string
	Type ast.Expr
}

type StructInfo struct {
	Name   string
	Fields []FieldInfo
}

func main() {
	// Сканируем текущую директорию и поддиректории
	err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil || !info.IsDir() || strings.HasPrefix(path, ".") {
			return err
		}
		processPackage(path)
		return nil
	})
	if err != nil {
		fmt.Printf("Error walking: %v\n", err)
	}
}

func processPackage(dir string) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, parser.ParseComments)
	if err != nil {
		return
	}

	for pkgName, pkg := range pkgs {
		var structs []StructInfo

		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				gen, ok := n.(*ast.GenDecl)
				if !ok || gen.Tok != token.TYPE {
					return true
				}

				// Ищем комментарий // generate:reset
				hasTag := false
				if gen.Doc != nil {
					for _, comment := range gen.Doc.List {
						if strings.Contains(comment.Text, "generate:reset") {
							hasTag = true
							break
						}
					}
				}

				if !hasTag {
					return true
				}

				for _, spec := range gen.Specs {
					ts := spec.(*ast.TypeSpec)
					st, ok := ts.Type.(*ast.StructType)
					if !ok {
						continue
					}

					info := StructInfo{Name: ts.Name.Name}
					for _, field := range st.Fields.List {
						for _, name := range field.Names {
							info.Fields = append(info.Fields, FieldInfo{
								Name: name.Name,
								Type: field.Type,
							})
						}
					}
					structs = append(structs, info)
				}
				return true
			})
		}

		if len(structs) > 0 {
			generateFile(dir, pkgName, structs)
		}
	}
}

func generateFile(dir, pkgName string, structs []StructInfo) {
	funcMap := template.FuncMap{
		"renderReset": renderReset,
	}

	tmpl, _ := template.New("reset").Funcs(funcMap).Parse(resetTemplate)

	data := struct {
		Package string
		Structs []StructInfo
	}{
		Package: pkgName,
		Structs: structs,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		fmt.Printf("Template error: %v\n", err)
		return
	}

	// Форматируем код
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("Format error: %v\n", err)
		formatted = buf.Bytes()
	}

	outputPath := filepath.Join(dir, "reset.gen.go")
	os.WriteFile(outputPath, formatted, 0644)
	fmt.Printf("Generated %s\n", outputPath)
}

// renderReset — это "движок" логики сброса, используемый внутри шаблона
func renderReset(prefix, name string, expr ast.Expr) string {
	accessor := prefix + name

	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "string":
			return fmt.Sprintf("%s = \"\"", accessor)
		case "bool":
			return fmt.Sprintf("%s = false", accessor)
		case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64":
			return fmt.Sprintf("%s = 0", accessor)
		default:
			// Для именованных типов вызываем Reset
			return fmt.Sprintf("%s.Reset()", accessor)
		}

	case *ast.ArrayType:
		return fmt.Sprintf("%s = %s[:0]", accessor, accessor)

	case *ast.MapType:
		return fmt.Sprintf("clear(%s)", accessor)

	case *ast.StarExpr:
		// Рекурсивно обрабатываем указатель
		inner := renderReset("*"+accessor, "", t.X)
		return fmt.Sprintf("if %s != nil {\n    %s\n}", accessor, inner)

	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.Reset()", accessor)

	default:
		return ""
	}
}
